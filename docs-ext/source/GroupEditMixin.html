<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">Ext.define(&#39;CpsiMapview.controller.grid.GroupEditMixin&#39;, {
    extend: &#39;Ext.Mixin&#39;,
    requires: [&#39;Ext.menu.Menu&#39;],
    mixinConfig: {
        on: {
            init: function () {
                var me = this;
                var view = this.getView();

                view.on(&#39;beforerender&#39;, function (grid) {
                    var dropdownMenu = grid.headerCt.getMenu();
                    dropdownMenu.on({
                        beforeshow: me.onHeaderMenuBeforeShow,
                        scope: me
                    });

                    // Add custom menu items to the default grid menu
                    dropdownMenu.insert(dropdownMenu.items.length - 2, [{
                        itemId: &#39;groupEditorMenuItem&#39;,
                        text: &#39;Group Edit&#39;,
                        tooltip: &#39;Group Edit mode must be enabled to use this menu. If you do not see the Group Edit button, you may not have sufficient permissions for grid editing.&#39;,
                        bind: {
                            disabled: &#39;{!isGroupEditingEnabled}&#39;
                        }
                    }]);
                });

                // Hide the checkbox selection column on initial load
                view.on(&#39;render&#39;, function (grid) {
                    var c = grid.columnManager.getFirst();
                    if (c) c.hide();
                });

                view.on(&#39;staterestore&#39;, function (grid, state) {
                    grid.getViewModel().set(&#39;isGroupEditingEnabled&#39;, state.isGroupEditingEnabled);
                });
            }
        }
    },

<span id='global-method-onGroupEditToggle'>    /**
</span>     * When the Group Edit is clicked then show the record checkbox
     * column, remove any selections, and disable paging so all
     * records are displayed
     * @param {any} btn
     * @param {any} state
     */
    onGroupEditToggle: function (btn, state) {
        var grid = this.getView();
        grid.getViewModel().set(&#39;isGroupEditingEnabled&#39;, state);
        if (state) {
            grid.columnManager.getFirst().show();
        } else {
            grid.columnManager.getFirst().hide();
        }
        grid.selModel.deselectAll();
    },

    onHeaderMenuBeforeShow: function (menu) {
        var me = this;
        var menuItem = menu.down(&#39;#groupEditorMenuItem&#39;);

        // check if it is a column that can be bulk edited
        if (!menu.activeHeader.groupEditable) {
            menuItem.hide(); // simply hide the menu if it is not editable
        } else {
            var newMenu = menuItem.menu;

            if (newMenu) {
                newMenu.removeAll();
            } else {
                newMenu = menuItem.menu = Ext.create(&#39;Ext.menu.Menu&#39;);
            }

            var newMenuItems = me.createGroupEditMenuItems(menu);
            newMenu.add(newMenuItems);
            menuItem.show();
        }
    },

    createGroupEditMenuItems: function (menu) {
        var me = this;
        var grid = me.getView();
        var newMenuItem;
        var newMenuItems = [];
        var activeHeader = menu.activeHeader;
        var filterType = activeHeader.filter.type || &#39;&#39;;
        switch (filterType.toLowerCase()) {
            case &#39;list&#39;:
                var ff = menu.down(&#39;#filters&#39;);
                // create menu options based on the filter options
                Ext.each(ff.menu.items.items, function (item) {

                    if (item.value === -1) {
                        // don not create a &quot;No Data&quot; option
                        // but continue creating the other items
                        return true;
                    }

                    newMenuItem = {
                        text: item.text,
                        value: item.value,
                        handler: function (item, event) {
                            event.stopPropagation();

                            // get the list of Ids that will be updated
                            var list = grid.selModel.getSelection().map(function (x) {
                                return x.id;
                            });

                            me.onGroupUpdate(activeHeader, list, item.value);
                        }
                    };

                    newMenuItems.push(newMenuItem);
                });
                break;
            case &#39;boolean&#39;:
                // create menu options for true and false
                var trueText = activeHeader.trueText || &#39;true&#39;;
                var falseText = activeHeader.falseText || &#39;false&#39;;
                var items = [{ text: trueText, value: true }, { text: falseText, value: false }];

                Ext.each(items, function (item) {
                    newMenuItem = {
                        text: item.text,
                        value: item.value,
                        handler: function (item, event) {
                            event.stopPropagation();

                            // get the list of Ids that will be updated
                            var list = grid.selModel.getSelection().map(function (x) {
                                return x.id;
                            });

                            me.onGroupUpdate(activeHeader, list, item.value);
                        }
                    };

                    newMenuItems.push(newMenuItem);
                });
                break;
            case &#39;number&#39;:
                newMenuItem = {
                    xtype: &#39;numberfield&#39;,
                    width: 300,
                    margin: 0,
                    emptyText: &#39;Enter a number and press Enter&#39;,
                    allowBlank: true,
                    allowDecimals: false,
                    allowExponential: false,
                    maxLength: 5,
                    minValue: 0, // no negative numbers
                    enableKeyEvents: true,
                    listeners: {
                        keypress: function (textField, event) {
                            if (event.keyCode === Ext.event.Event.ENTER &amp;&amp; textField.isValid()) {
                                event.stopPropagation();
                                // get the list of Ids that will be updated
                                var list = grid.selModel.getSelection().map(function (x) {
                                    return x.id;
                                });
                                me.onGroupUpdate(activeHeader, list, textField.getValue());
                            }
                        },
                        scope: me
                    }
                };
                newMenuItems.push(newMenuItem);
                break;
            default:
                Ext.log.error(&#39;Filter type &quot;&#39; + filterType.toLowerCase() + &#39;&quot; not supported&#39;);
                break;
        }

        return newMenuItems;
    },

    onGroupUpdate: function (activeHeader, selectedIDs, newValue) {

        var me = this;

        Ext.Msg.show({
            title: &#39;Group editing&#39;,
            message: &#39;You are about to update &#39; + selectedIDs.length + &#39; selected items, do you want to proceed?&#39;,
            buttons: Ext.Msg.YESNO,
            scope: me,
            fn: function (buttonId) {

                if (buttonId == &#39;yes&#39;) {

                    var data = {};
                    var idProperty = me.getViewModel().get(&#39;idProperty&#39;);
                    var serviceUrl = me.getViewModel().get(&#39;serviceUrl&#39;) + activeHeader.groupEditService;

                    // first char to lower case to match backend naming
                    idProperty = idProperty[0].toLowerCase() + idProperty.slice(1);
                    data[idProperty] = selectedIDs;
                    data[activeHeader.groupEditDataProp] = newValue;

                    Ext.Ajax.request({
                        url: serviceUrl,
                        method: &#39;POST&#39;,
                        jsonData: data,
                        success: function (response) {
                            var resp = Ext.decode(response.responseText);
                            if (resp.success === true) {
                                // trigger a refresh of all related layers and stores, including the grid itself
                                // as defined by syncLayerKeys and syncStoreIds in the model
                                var clearPaging = false;
                                me.refreshStore(clearPaging);
                                var force = true;
                                me.updateAssociatedLayers(force);
                            } else {
                                Ext.Msg.show({
                                    title: &#39;Error&#39;,
                                    message: &#39;Error updating the selected records: &#39; + resp.message,
                                    buttons: Ext.Msg.OK,
                                    icon: Ext.window.MessageBox.ERROR
                                });
                            }
                        },
                        failure: function () {
                            Ext.Msg.show({
                                title: &#39;Error&#39;,
                                message: &#39;Error connecting to the update service &#39; + serviceUrl,
                                buttons: Ext.Msg.OK,
                                icon: Ext.window.MessageBox.ERROR
                            });
                        }
                    });
                }
            }
        });
    }

});
</pre>
</body>
</html>
