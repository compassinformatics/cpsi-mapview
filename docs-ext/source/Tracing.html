<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='CpsiMapview-util-Tracing'>/**
</span> * Util class for tracing related functions.
 *
 * @class CpsiMapview.util.Tracing
 */
Ext.define(&#39;CpsiMapview.util.Tracing&#39;, {

    statics: {

<span id='CpsiMapview-util-Tracing-static-method-computeModulo'>        /**
</span>         * Compute the modulo for negative values.
         *
         * Example: staticMe.computeModulo(-1, 4) returns 3
         *
         * Taken from the official OpenLayers example:
         * https://openlayers.org/en/latest/examples/tracing.html
         *
         * @param {Number} a The first number
         * @param {Number} b The second number
         *
         * @returns {Number} The modulo
         */
        computeModulo: function (a, b) {
            return ((a % b) + b) % b;
        },

<span id='CpsiMapview-util-Tracing-static-method-lineStringPopulated'>        /**
</span>         * Checks if a LineString is is populated i.e. is not empty.
         *
         * @param {ol.Feature} feature The feature to check
         * @returns {Boolean} true/false if LineString is populated, undefined if something unexpected happened
         */
        lineStringPopulated: function (feature) {
            if (!feature) {
                return;
            }
            var geom = feature.getGeometry();
            if (!geom) {
                return;
            }

            var type = geom.getType();
            if (type != &#39;LineString&#39;) {
                return;
            }
            var coords = geom.getCoordinates();
            if (!coords) {
                return;
            }
            return coords.length &gt;= 2;
        },

<span id='CpsiMapview-util-Tracing-method-'>        /**
</span>         * Finds the index of a coordinate in a coordinate array
         * by only comparing its value.
         *
         * @param {ol.coordinate.Coordinate[]} coordinateArray The coordinate array
         * @param {ol.coordinate.Coordinate} coordToFind The coordinate to find
         * @returns {Number} The index of the coordinate, or -1 if not found
         */
<span id='CpsiMapview-util-Tracing-static-method-getCoordIndex'>        // TODO: use Ext.Array.reduce instead of Ext.Array.findBy you can omit the second loop
</span>        getCoordIndex: function (coordinateArray, coordToFind) {
            var found = Ext.Array.findBy(coordinateArray, function (c) {
                return Ext.Array.equals(c, coordToFind);
            });
            return coordinateArray.indexOf(found);
        },

<span id='CpsiMapview-util-Tracing-static-method-linesTouchAtStartEndPoint'>        /**
</span>         * Checks if two LineString geometries are touching at only startpoint and/or endpoint.
         *
         * @param {ol.geom.LineString} lineA The first LineString
         * @param {ol.geom.LineString} lineB The second LineString
         *
         * @returns {Boolean} If lines are touching.
         */
        linesTouchAtStartEndPoint: function (lineA, lineB) {
            var firstA = lineA.getFirstCoordinate();
            var lastA = lineA.getLastCoordinate();

            var firstB = lineB.getFirstCoordinate();
            var lastB = lineB.getLastCoordinate();

            var endStart = Ext.Array.equals(lastA, firstB);
            var endEnd = Ext.Array.equals(lastA, lastB);
            var startStart = Ext.Array.equals(firstA, firstB);
            var startEnd = Ext.Array.equals(firstA, lastB);
            return endStart || endEnd || startStart || startEnd;
        },

<span id='CpsiMapview-util-Tracing-static-method-lineInteriorTouchesLineStartEnd'>        /**
</span>         * Checks if the interior of one line touches the startpoint
         * or the endpoint of another line. If yes, the touching point is returned.
         *
         * @param {ol.geom.LineString} lineGeomA The first LineString
         * @param {ol.geom.LineString} lineGeomB The second LineString
         * @returns {ol.coordinate.Coordinate} The touching coordinate or null
         */
        lineInteriorTouchesLineStartEnd: function (lineA, lineB) {

            var firstB = lineB.getFirstCoordinate();
            var lastB = lineB.getLastCoordinate();

            if (lineA.intersectsCoordinate(firstB)) {
                return firstB;
            }

            if (lineA.intersectsCoordinate(lastB)) {
                return lastB;
            }

        },

<span id='CpsiMapview-util-Tracing-static-method-lineStartEndTouchesLineInterior'>        /**
</span>         * Checks if the startpoint or the endpoint of a line touches the interior of another line.
         * If yes, the touching point is returned.
         *
         * @param {ol.geom.LineString} lineGeomA The first LineString
         * @param {ol.geom.LineString} lineGeomB The second LineString
         * @returns {ol.coordinate.Coordinate} The touching coordinate
         */
        lineStartEndTouchesLineInterior: function (lineA, lineB) {
            var firstA = lineA.getFirstCoordinate();
            var lastA = lineA.getLastCoordinate();

            if (lineB.intersectsCoordinate(firstA)) {
                return firstA;
            }
            if (lineB.intersectsCoordinate(lastA)) {
                return lastA;
            }

        },

<span id='CpsiMapview-util-Tracing-static-method-computeLength'>        /**
</span>         * Compute the length of the [a, b] segment.
         *
         * Taken from the official OpenLayers example:
         * https://openlayers.org/en/latest/examples/tracing.html
         *
         * @param {ol.coordinate.Coordinate} a The start coordinate of the segment
         * @param {ol.coordinate.Coordinate} b The end coordinate of the segment
         *
         * @returns {ol.coordinate.Coordinate} The length of the segment
         */
        computeLength: function (a, b) {
            return Math.sqrt(
                (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1])
            );
        },

<span id='CpsiMapview-util-Tracing-static-method-getClosestCoordinateToPoint'>        /**
</span>         * Finds the closest coordinate to a point.
         *
         * @param {ol.coordinate.Coordinate[]} coordinateArray An array of coordinates
         * @param {ol.coordinate.Coordinate} pointCoordinate The point coordinate
         *
         * @returns {ol.coordinate.Coordinate} The found coordinate
         */
        getClosestCoordinateToPoint: function (coordinateArray, pointCoordinate) {
            var staticMe = CpsiMapview.util.Tracing;

            var found, length;
            Ext.each(coordinateArray, function (c) {
                var tmpLength = staticMe.computeLength(c, pointCoordinate);
                if (!length || tmpLength &lt; length) {
                    length = tmpLength;
                    found = c;
                }
            });
            return found;
        },

<span id='CpsiMapview-util-Tracing-static-method-coordIsOnSegment'>        /**
</span>         * Checks if coordinate c is on the [a, b] segment.
         *
         * Taken from the official OpenLayers example:
         * https://openlayers.org/en/latest/examples/tracing.html
         *
         * @param {ol.coordinate.Coordinate} c The coordinate to check
         * @param {ol.coordinate.Coordinate} a The start coordinate of the segment
         * @param {ol.coordinate.Coordinate} b The end coordinate of the segment
         *
         * @returns {Boolean} If coordinate c is on the [a, b] segment
         */
        coordIsOnSegment: function (c, a, b) {
            var staticMe = CpsiMapview.util.Tracing;

            var lengthAc = staticMe.computeLength(a, c);
            var lengthAb = staticMe.computeLength(a, b);
            var dot =
                ((c[0] - a[0]) * (b[0] - a[0]) + (c[1] - a[1]) * (b[1] - a[1])) / lengthAb;
            return Math.abs(lengthAc - dot) &lt; 1e-6 &amp;&amp; lengthAc &lt; lengthAb;
        },

<span id='CpsiMapview-util-Tracing-static-method-concatLineCoords'>        /**
</span>         * Concatenate two coordinate arrays if they are touching at the startpoint or endpoint.
         * It takes the direction of the arrays into account.
         *
         * @param {ol.coordinate.Coordinate[]} aLineCoords The first coordinate array
         * @param {ol.coordinate.Coordinate[]} bLineCoords The second coordinate array
         * @returns {ol.coordinate.Coordinate[]} The combined coordinate array if input arrays are touching, empty array otherwise
         */
        concatLineCoords: function (aLineCoords, bLineCoords) {

            var inputValid =
                Ext.isArray(aLineCoords) &amp;&amp;
                aLineCoords.length &gt;= 2 &amp;&amp;
                Ext.isArray(bLineCoords) &amp;&amp;
                bLineCoords.length &gt;= 2;

            if (!inputValid) {
                return;
            }

            var aFirst = aLineCoords[0];
            var aLast = aLineCoords[aLineCoords.length - 1];

            var bFirst = bLineCoords[0];
            var bLast = bLineCoords[bLineCoords.length - 1];

            var lastFirst = Ext.Array.equals(aLast, bFirst);
            var lastLast = Ext.Array.equals(aLast, bLast);
            var firstFirst = Ext.Array.equals(aFirst, bFirst);
            var firstLast = Ext.Array.equals(aFirst, bLast);

            if (lastLast) {
                // reverse second array
                bLineCoords.reverse();

            } else if (firstFirst) {
                // reverse first array
                aLineCoords.reverse();

            } else if (firstLast) {
                // reverse both arrays
                aLineCoords.reverse();
                bLineCoords.reverse();

            } else if (!lastFirst) {
                // lines do not touch
                Ext.Logger.warn(&#39;Cannot concat lines, because they do not touch.&#39;);
                return undefined;
            }
            // remove intersecting vertex
            aLineCoords.pop();
            var resultCoords = aLineCoords.concat(bLineCoords);
            return resultCoords;
        },

        // TODO: this code was originally built for polygons and
        //       might need more adjustment for simple linestrings
<span id='CpsiMapview-util-Tracing-static-method-getPartialSegmentCoords'>        /**
</span>         * Returns a coordinates array which contains the segments of the traced feature
         * between the start and the end point.
         *
         * The basic functionality is taken from the official OpenLayers example:
         * https://openlayers.org/en/latest/examples/tracing.html
         *
         * @param {ol.Feature} feature The feature to trace
         * @param {ol.coordinate.Coordinate} startPoint The coordinate of the start point
         * @param {ol.coordinate.Coordinate} endPoint The coordinate of the end point
         *
         * @returns {ol.coordinate.Coordinate[]} The coordinates of the traced segment.
         */
        getPartialSegmentCoords: function (feature, startPoint, endPoint) {
            var staticMe = CpsiMapview.util.Tracing;
            var geometry = feature.getGeometry();
            var ringCoords;
            if (geometry.getType() === &#39;MultiPolygon&#39;) {
                geometry = geometry.getPolygon(0);
                ringCoords = geometry.getLinearRing().getCoordinates();
            } else if (geometry.getType() === &#39;Polygon&#39;) {
                ringCoords = geometry.getLinearRing().getCoordinates();
            } else if (geometry.getType() === &#39;LineString&#39;) {
                ringCoords = geometry.getCoordinates();
            } else {
                Ext.Logger.warn(&#39;Tracing only works for LineString, Polygon and MultiPolygon&#39;);
                return;
            }

            var i,
                pointA,
                pointB,
                startSegmentIndex = -1;
            for (i = 0; i &lt; ringCoords.length; i++) {
                pointA = ringCoords[i];
                pointB = ringCoords[staticMe.computeModulo(i + 1, ringCoords.length)];

                // check if this is the start segment dot product
                if (staticMe.coordIsOnSegment(startPoint, pointA, pointB)) {
                    startSegmentIndex = i;
                    break;
                }
            }

            var cwCoordinates = [];
            var cwLength = 0;
            var ccwCoordinates = [];
            var ccwLength = 0;

            // build clockwise coordinates
            for (i = 0; i &lt; ringCoords.length; i++) {
                pointA =
                    i === 0
                        ? startPoint
                        : ringCoords[staticMe.computeModulo(i + startSegmentIndex, ringCoords.length)];
                pointB = ringCoords[staticMe.computeModulo(i + startSegmentIndex + 1, ringCoords.length)];
                cwCoordinates.push(pointA);

                if (staticMe.coordIsOnSegment(endPoint, pointA, pointB)) {
                    cwCoordinates.push(endPoint);
                    cwLength += staticMe.computeLength(pointA, endPoint);
                    break;
                } else {
                    cwLength += staticMe.computeLength(pointA, pointB);
                }
            }

            // build counter-clockwise coordinates
            for (i = 0; i &lt; ringCoords.length; i++) {
                pointA = ringCoords[staticMe.computeModulo(startSegmentIndex - i, ringCoords.length)];
                pointB =
                    i === 0
                        ? startPoint
                        : ringCoords[staticMe.computeModulo(startSegmentIndex - i + 1, ringCoords.length)];
                ccwCoordinates.push(pointB);

                if (staticMe.coordIsOnSegment(endPoint, pointA, pointB)) {
                    ccwCoordinates.push(endPoint);
                    ccwLength += staticMe.computeLength(endPoint, pointB);
                    break;
                } else {
                    ccwLength += staticMe.computeLength(pointA, pointB);
                }
            }

            // keep the shortest path
            return ccwLength &lt; cwLength ? ccwCoordinates : cwCoordinates;
        }

    }
}
);
</pre>
</body>
</html>
