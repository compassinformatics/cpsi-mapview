<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='CpsiMapview-plugin-TreeColumnInResolutionRange'>/**
</span> * Plugin to change opacity and font style of a layer tree node
 * if assigned layer is not in range
 */
Ext.define(&#39;CpsiMapview.plugin.TreeColumnInResolutionRange&#39;, {
    extend: &#39;Ext.plugin.Abstract&#39;,
    alias: &#39;plugin.cmv_tree_inresolutionrange&#39;,
<span id='CpsiMapview-plugin-TreeColumnInResolutionRange-property-pluginId'>    pluginId: &#39;cmv_tree_inresolutionrange&#39;,
</span>
    statics: {
<span id='CpsiMapview-plugin-TreeColumnInResolutionRange-static-property-LINE_BREAK'>        LINE_BREAK: &#39;&lt;br class=&quot;cpsi-resolution-range-popup-br&quot; /&gt;&#39;
</span>    },

<span id='CpsiMapview-plugin-TreeColumnInResolutionRange-method-init'>    /**
</span>     * Initialize TreeColumnInResolutionRange plugin
     * @param {Ext.grid.column.Column} column The column to register the plugin
     *     for
     * @private
     */
    init: function(column) {
        var me = this;
        if (!(column instanceof Ext.grid.column.Column)) {
            Ext.log.warn(&#39;Plugin shall only be applied to instances of&#39; +
                  &#39; Ext.grid.column.Column&#39;);
            return;
        }
        var mapComponent = BasiGX.util.Map.getMapComponent();
        mapComponent.getStore().setChangeLayerFilterFn(me.changeLayerFilterFn);

        var map = mapComponent.getMap();
        var mapView = map.getView();

        mapView.on(&#39;change:resolution&#39;, function() {
            me.updateTreeNode(mapView);
        });

        me.cmp.up(&#39;treepanel&#39;).on(&#39;cmv-init-layertree&#39;, function () {
            me.updateTreeNode(mapView);
        });

        me.cmp.up(&#39;treepanel&#39;).on(&#39;boxready&#39;, function (tp) {
            if (tp.getStore().count()) {
                map.getView().dispatchEvent(&#39;change:resolution&#39;);
            }
        });
    },

<span id='CpsiMapview-plugin-TreeColumnInResolutionRange-method-changeLayerFilterFn'>    /**
</span>     * Custom change layer filter function to be applied to store
     * @param {GeoExt.data.model.Layer} record An GeoExt layer model instance
     * @private
     */
    changeLayerFilterFn: function (record) {
        var layer = this;
        return layer.id === record.getOlLayer().id;
    },

<span id='CpsiMapview-plugin-TreeColumnInResolutionRange-method-updateTreeNode'>    /**
</span>     * When resolution changes in map: update tree nodes if needed
     * @param {ol.View} mapView The OL map view
     */
    updateTreeNode: function (mapView) {
        var me = this;
        var unit = mapView.getProjection().getUnits();
        var resolution = mapView.getResolution();
        var treepanel = me.cmp.up(&#39;treepanel&#39;);
        var nodeStore = treepanel.getStore();
        var treeNodes = nodeStore.getData();
        Ext.each(treeNodes.items, function (node) {
            var inRange = me.layerInResolutionRange(node.getOlLayer(), resolution);
            node[inRange ? &#39;removeCls&#39; : &#39;addCls&#39;](&#39;cpsi-tree-node-disabled&#39;);
            var descriptionBefore = node.getOlLayer().get(&#39;description&#39;);
            var description = me.getTooltipText(node, inRange, unit);
            var changed = description !== descriptionBefore;
            node.getOlLayer().set(&#39;description&#39;, description);
            if (changed) {
                node.set(&#39;qtip&#39;, description);
            }
        });
        // This triggers the rendering if any existing StyleSwitcherRadioGroups
        treepanel.fireEvent(&#39;itemupdate&#39;);
    },

<span id='CpsiMapview-plugin-TreeColumnInResolutionRange-method-layerInResolutionRange'>    /**
</span>     * Check if layer is visible in current resolution range
     *
     * @param {ol.layer.Base} layer The OpenLayers layer
     * @param {Number} currentRes The current map resolution
     *
     * @returns {Boolean} layer is in resolution range?
     */
    layerInResolutionRange: function (layer, currentRes) {
        if (!layer || !currentRes) {
            // It is questionable what we should return in this case, I opted for
            // false, since we cannot sanely determine a correct answer.
            return false;
        }
        var layerMinRes = layer.getMinResolution(); // default: 0 if unset
        var layerMaxRes = layer.getMaxResolution(); // default: Infinity if unset
        // minimum resolution is inclusive, maximum resolution exclusive
        var within = currentRes &gt;= layerMinRes &amp;&amp; currentRes &lt; layerMaxRes;
        return within;
    },

<span id='CpsiMapview-plugin-TreeColumnInResolutionRange-method-getTooltipText'>    /**
</span>     * Get tooltip text for node
     *
     * @param {Ext.data.NodeInterface} node The layer tree node
     * @param {Boolean} inRange Is layer in range
     * @param {String} unit The unit defined in current map projection
     *
     * @returns {String} The toolip text valid for current range
     */
    getTooltipText: function (node, inRange, unit) {
        var staticMe = CpsiMapview.plugin.TreeColumnInResolutionRange;
        if (!Ext.isDefined(node.originalQtip)) {
            node.originalQtip = node.getOlLayer().get(&#39;description&#39;) || &#39;&#39;;
        }

        if (inRange) {
            return node.originalQtip.length &gt; 0 ? node.originalQtip : undefined;
        }

        var currentTip = node.getOlLayer().get(&#39;description&#39;);
        if (currentTip &amp;&amp; (currentTip.indexOf(staticMe.LINE_BREAK) &gt; -1 ||
            currentTip.indexOf(&#39;Visible&#39;) &gt; -1)) {
            return currentTip;
        }

        var description = this.enhanceTooltip(node.getOlLayer(), unit);
        return description;
    },

<span id='CpsiMapview-plugin-TreeColumnInResolutionRange-method-enhanceTooltip'>    /**
</span>     * Adds scale restriction information to decription text
     * @param {ol.layer.Base} layer The OpenLayers layer
     * @param {String} unit The unit defined in current map projection
     *
     * @returns {String} The enhanced toolip text
     */
    enhanceTooltip: function (layer, unit) {
        var staticMe = CpsiMapview.plugin.TreeColumnInResolutionRange;
        var scale = &#39;&#39;, maxScale, minScale;
        maxScale = BasiGX.util.Map.getScaleForResolution(layer.getMaxResolution(), unit);
        minScale = BasiGX.util.Map.getScaleForResolution(layer.getMinResolution(), unit);
        if (maxScale) {
            // round to nearest 10
            maxScale = Math.round(maxScale / 10) * 10;
            maxScale = Ext.util.Format.number(maxScale, &#39;0,000&#39;);
        }
        if (minScale) {
            // round both to nearest 10
            minScale = Math.round(minScale / 10) * 10;
            minScale = Ext.util.Format.number(minScale, &#39;0,000&#39;);
        }

        if (maxScale &amp;&amp; minScale) {
            scale = Ext.String.format(&#39;Visible between &lt;b&gt;1:{0}&lt;/b&gt; and &lt;b&gt;1:{1}&lt;/b&gt;&#39;, minScale, maxScale);
        } else {
            if (maxScale) {
                scale = Ext.String.format(&#39;Visible at &lt;b&gt;1:{0}&lt;/b&gt; and above&#39;, maxScale);
            }
            if (minScale) {
                scale = Ext.String.format(&#39;Visible at &lt;b&gt;1:{0}&lt;b&gt; and below&#39;, minScale);
            }
        }
        return layer.get(&#39;description&#39;) ?
            (layer.get(&#39;description&#39;).trim() + staticMe.LINE_BREAK + scale) :
            scale;
    }

});
</pre>
</body>
</html>
