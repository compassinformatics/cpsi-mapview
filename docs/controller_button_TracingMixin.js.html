<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: controller/button/TracingMixin.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: controller/button/TracingMixin.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * A mixin to add tracing functionality to a drawing tool.
 *
 * The basic functionality is taken from the official OpenLayers example:
 * https://openlayers.org/en/latest/examples/tracing.html
 *
 * @class CpsiMapview.controller.button.TracingMixin
 */
Ext.define('CpsiMapview.controller.button.TracingMixin', {
    extend: 'Ext.Mixin',

    requires: [
        'BasiGX.util.Layer',
        'CpsiMapview.util.Tracing'
    ],

    /**
     * The style of the preview line during tracing.
     */
    previewStyle: new ol.style.Style({
        stroke: new ol.style.Stroke({
            color: 'rgba(255, 0, 0, 1)',
            width: 10,
        })
    }),

    /**
     * Used to store the position of the last mouse coord, taking into account snapping
     */
    lastSnappedCoord: null,

    /**
     * Interaction to track and populate lastSnappedCoord
     */
    getSnapCoordinateInteraction: null,

    /**
     * Enhances drawing functionality by adding tracing to it.
     *
     * @param {String[]} tracingLayerKeys The keys of the layers to trace
     * @param {ol.interaction.Draw} drawInteraction draw interaction to attach the tracing on
     * @param {Boolean} [showTraceableEdges=false] If the traceable edges shall be shown (useful for debugging)
     */
    initTracing: function (tracingLayerKeys, drawInteraction, showTraceableEdges) {
        var me = this;

        if (me.getView()) {
            me.getView().fireEvent('tracingstart');
        }

        if (!drawInteraction) {
            return;
        }

        me.tracingDrawInteraction = drawInteraction;

        me.onTracingDrawStart = me.onTracingDrawStart.bind(this);
        me.onTracingDrawEnd = me.onTracingDrawEnd.bind(this);

        me.tracingActive = false;
        me.tracingDrawInteraction.on('drawstart', me.onTracingDrawStart);
        me.tracingDrawInteraction.on('drawend', me.onTracingDrawEnd);
        me.trackSnappedCoords();

        if (!tracingLayerKeys) {
            return;
        }
        // get tracing layers
        me.tracingLayers = [];
        Ext.each(tracingLayerKeys, function (key) {
            var foundLayers = BasiGX.util.Layer.getLayersBy('layerKey', key);
            if (foundLayers.length > 0) {
                me.tracingLayers.push(foundLayers[0]);
            }
        });

        // the options for the eachFeature functions
        me.forEachFeatureOptions = {
            hitTolerance: 10,
            layerFilter: function (layer) {
                return Ext.Array.contains(me.tracingLayers, layer);
            },
        };

        me.tracingFeature = new ol.Feature({
            geometry: new ol.geom.LineString([]),
        });
        me.tracingFeatureArray = [];
        me.tracingStartPoint = null;
        me.tracingEndPoint = null;

        // For debugging the traceable edges can be displayed
        me.tracingVector = new ol.layer.Vector({
            source: new ol.source.Vector({
                features: [me.tracingFeature],
            }),
            style: new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: [255, 255, 0, 0.5],
                    width: 25
                })
            })
        });
        if (showTraceableEdges) {
            me.map.addLayer(me.tracingVector);
        }

        // the tracing util
        me.tracingUtil = CpsiMapview.util.Tracing;

        // the visible tracing line while editing
        me.previewLine = new ol.Feature({
            geometry: new ol.geom.LineString([]),
        });

        me.previewVector = new ol.layer.Vector({
            source: new ol.source.Vector({
                features: [me.previewLine],
            }),
            style: me.previewStyle
        });
        me.map.addLayer(me.previewVector);

        // bind scope to listener functions
        me.onTracingPointerMove = me.onTracingPointerMove.bind(me);
        me.onTracingMapClick = me.onTracingMapClick.bind(me);

        me.map.on('click', me.onTracingMapClick);
        me.map.on('pointermove', me.onTracingPointerMove);
    },

    /**
     * Sets the variable 'me.tracingActive' to true.
     */
    onTracingDrawStart: function () {
        var me = this;
        me.tracingActive = true;
    },

    /**
     * Sets the variable 'me.tracingActive' to false.
     */
    onTracingDrawEnd: function () {
        var me = this;
        me.tracingActive = false;
        // Clear previous tracingFeature data
        me.tracingFeature.getGeometry().setCoordinates([]);
        me.tracingFeatureArray = [];
        me.previewLine.getGeometry().setCoordinates([]);
    },

    /**
     * Remove listeners and layers
     */
    cleanupTracing: function () {
        var me = this;

        // nothing to cleanup if tracing has not been initialised
        if (!me.tracingDrawInteraction) {
            return;
        }

        me.map.removeLayer(me.previewVector);
        me.map.removeLayer(me.tracingVector);
        me.map.un('click', me.onTracingMapClick);
        me.map.un('pointermove', me.onTracingPointerMove);
        me.tracingDrawInteraction.un('drawstart', me.onTracingDrawStart);
        me.tracingDrawInteraction.un('drawend', me.onTracingDrawEnd);
        me.map.removeInteraction(me.getSnapCoordinateInteraction);
    },

    /**
     * Add a generic Interaction to the map before the last Snap interaction
     * So that we can collected the coordinates of the latest snapped edge/vertex/node
     * The new Interaction needs to be before the last Snap interaction so that the
     * Snap interaction modifies the coordinates to the snapped edge/vertex/node
     * And passes them down to the next interaction
     */
    trackSnappedCoords: function () {
        var me = this;
        var interactions = me.map.getInteractions();
        var lastSnapInteractionIndex;

        me.getSnapCoordinateInteraction = new ol.interaction.Interaction({
            handleEvent: function (e) {
                me.lastSnappedCoord = e.coordinate;
                return true;
            }
        });

        interactions.forEach(function (interaction, i) {
            if (interaction instanceof ol.interaction.Snap) {
                lastSnapInteractionIndex = i;
            }
        });

        interactions.insertAt(lastSnapInteractionIndex, me.getSnapCoordinateInteraction);
    },

    /**
     * Listen to click to start and end the tracing.
     *
     * @param {Event} event The OpenLayers click event.
     */
    onTracingMapClick: function (event) {
        var me = this;

        // Ignore the event if drawing is finished
        if (!me.tracingActive) {
            return;
        }

        var hit = false;
        me.map.forEachFeatureAtPixel(
            event.pixel,
            function (feature) {
                if (me.tracingUtil.lineStringPopulated(me.tracingFeature) &amp;&amp; !me.tracingFeatureArray.includes(feature)) {
                    return;
                }

                hit = true;

                // second click on the tracing feature: append the ring coordinates
                if (me.tracingUtil.lineStringPopulated(me.tracingFeature) &amp;&amp; me.tracingFeatureArray.includes(feature)) {
                    me.tracingEndPoint = me.lastSnappedCoord;
                    var appendCoords = me.tracingUtil.getPartialSegmentCoords(
                        me.tracingFeature,
                        me.tracingStartPoint,
                        me.tracingEndPoint
                    );

                    // send coordinates to parent component
                    if (me.getView()) {
                        // NOTE: we transfer the coordinates via an event,
                        //       but this mixin has access to the drawInteraction as well,
                        //       hence we could directly apply the coordinates to the drawInteraction
                        //       without an event
                        me.getView().fireEvent('tracingend', appendCoords);
                    }

                    me.tracingFeature.getGeometry().setCoordinates([]);
                    me.tracingFeatureArray = [];
                    me.previewLine.getGeometry().setCoordinates([]);
                }

                var geom = feature.clone().getGeometry();
                // start tracing on the feature ring
                var coords = geom.getCoordinates();

                me.tracingFeature.getGeometry().setCoordinates(
                    coords
                );
                me.tracingFeatureArray.push(feature);
                me.tracingStartPoint = me.lastSnappedCoord;
            },
            me.forEachFeatureOptions
        );

        if (!hit) {
            // clear current tracing feature &amp; preview
            me.previewLine.getGeometry().setCoordinates([]);
            me.tracingFeature.getGeometry().setCoordinates([]);
            me.tracingFeatureArray = [];
        }
    },

    /**
     * Create the tracing geometry when pointer is moved.
     *
     * @param {Event} event The OpenLayers move event
     */
    onTracingPointerMove: function (event) {
        var me = this;
        var pixel = event.pixel;

        if (me.tracingUtil.lineStringPopulated(me.tracingFeature) &amp;&amp; me.tracingActive) {
            var coordOnFoundFeature = null;
            me.map.forEachFeatureAtPixel(
                pixel,
                function (foundFeature) {

                    // find coordinate on found feature
                    if (me.tracingFeatureArray.includes(foundFeature)) {
                        coordOnFoundFeature = me.map.getCoordinateFromPixel(pixel);
                    }

                    if (me.tracingFeatureArray.includes(foundFeature)) {
                        me.updateTraceableFeature(foundFeature);

                    } else {
                        // new feature found that needs to be added to tracingfeature

                        var foundGeom = foundFeature.getGeometry();
                        var tracingGeom = me.tracingFeature.getGeometry();

                        var touchingStartEnd = me.tracingUtil.linesTouchAtStartEndPoint(foundGeom, tracingGeom);

                        // TODO: the cases where lines touch at interior points only work in some cases
                        //       it might fail in some edge cases, also tracing consecutively on many
                        //       features does not work
                        var tracingInteriorTouchesFoundFeatureStartEnd = me.tracingUtil.lineInteriorTouchesLineStartEnd(tracingGeom, foundGeom);
                        var tracingStartEndTouchesFoundInterior = me.tracingUtil.lineStartEndTouchesLineInterior(tracingGeom, foundGeom);

                        if (touchingStartEnd) {
                            me.setNewTracingOnStartEndTouch(foundFeature);
                        } else if (tracingInteriorTouchesFoundFeatureStartEnd) {
                            me.setNewTracingOnInteriorStartEndTouch(foundFeature, tracingInteriorTouchesFoundFeatureStartEnd);
                        } else if (tracingStartEndTouchesFoundInterior) {
                            me.setNewTracingOnStartEndInteriorTouch(foundFeature, tracingStartEndTouchesFoundInterior, pixel);
                        }
                    }
                },
                me.forEachFeatureOptions
            );

            var previewCoords = [];
            if (coordOnFoundFeature) {
                me.tracingEndPoint = me.tracingFeature.getGeometry().getClosestPoint(coordOnFoundFeature);
                previewCoords = me.tracingUtil.getPartialSegmentCoords(
                    me.tracingFeature,
                    me.tracingStartPoint,
                    me.tracingEndPoint
                );
            }
            me.previewLine.getGeometry().setCoordinates(previewCoords);
        }
    },

    /**
     * Updates the currently active traceable feature.
     *
     * @param {ol.Feature} foundFeature The hovered feature found in the tracing feature array
     */
    updateTraceableFeature: function (foundFeature) {
        var me = this;

        // check if found feature is last of array
        var index = me.tracingFeatureArray.indexOf(foundFeature);
        if (index !== 0 &amp;&amp; (!index || index === -1)) {
            Ext.Logger.error('The found feature must be in the found features array.');
            return;
        }
        var notLastFeature = (index !== (me.tracingFeatureArray.length - 1));

        if (notLastFeature) {

            // remove all features after hovered feature
            me.tracingFeatureArray = me.tracingFeatureArray.slice(0, index + 1);
            // update coordinates of tracingFeature
            var updatedCoords = [];
            Ext.each(me.tracingFeatureArray, function (f) {
                var geom = f.getGeometry();
                var coords = geom.getCoordinates();

                if (updatedCoords &amp;&amp; updatedCoords.length === 0) {
                    updatedCoords = coords;
                } else {
                    updatedCoords = me.tracingUtil.concatLineCoords(updatedCoords, coords);
                }
            });

            // concatLineCoords can return undefined if lines do not touch
            if (updatedCoords) {
                me.tracingFeature.getGeometry().setCoordinates(updatedCoords);
            }
        }
    },

    /**
     * Sets the new tracing feature if it is touching via startpoint or endpoint.
     *
     * @param {ol.Feature} foundFeature The hovered feature to set as new tracing feature
     */
    setNewTracingOnStartEndTouch: function (foundFeature) {
        var me = this;
        var foundGeom = foundFeature.getGeometry();
        var tracingGeom = me.tracingFeature.getGeometry();
        var tracingCoords = tracingGeom.getCoordinates();

        var coords = foundGeom.getCoordinates();

        var resultCoords = me.tracingUtil.concatLineCoords(
            tracingCoords,
            coords
        );

        if (resultCoords) {
            me.tracingFeature.getGeometry().setCoordinates(resultCoords);
            me.tracingFeatureArray.push(foundFeature);
        }
    },

    /**
     * Sets the new tracing feature if interior of line touches the startpoint or the endpoint of another line.
     *
     * @param {ol.Feature} foundFeature The hovered feature to set as new tracing feature
     * @param {ol.coordinate.Coordinate} touchCoordinate The coordinate of the touching point
     */
    setNewTracingOnInteriorStartEndTouch: function (foundFeature, touchCoordinate) {
        var me = this;
        var tracingGeom = me.tracingFeature.getGeometry();
        var tracingCoords = tracingGeom.getCoordinates();

        var touchingIndex = me.tracingUtil.getCoordIndex(tracingCoords, touchCoordinate);

        var foundSplitPoint = me.tracingUtil.getClosestCoordinateToPoint(tracingCoords, me.tracingStartPoint);
        var startingPointIndex = me.tracingUtil.getCoordIndex(tracingCoords, foundSplitPoint);

        // we cut the tracing feature by the split point
        // we have to take the order into account
        var partUntilIntersection;
        if (touchingIndex &lt; startingPointIndex) {
            partUntilIntersection = tracingCoords.slice(touchingIndex, tracingCoords.length);
        } else {
            partUntilIntersection = tracingCoords.slice(0, touchingIndex + 1);
        }

        var newTracingCoords = me.tracingUtil.concatLineCoords(partUntilIntersection, foundFeature.getGeometry().getCoordinates());

        me.tracingFeature.getGeometry().setCoordinates(newTracingCoords);
        me.tracingFeatureArray.push(foundFeature);
    },

    /**
     * Sets the new tracing feature if startpoint or endpoint touches the interior of another line.
     *
     * @param {ol.Feature} foundFeature The hovered feature to set as new tracing feature
     * @param {ol.coordinate.Coordinate} touchCoordinate The coordinate of the touching point
     * @param {ol.pixel} pixel The pixel the user hovered on
     */
    setNewTracingOnStartEndInteriorTouch: function (foundFeature, touchCoordinate, pixel){
        var me = this;
        var foundGeom = foundFeature.getGeometry();
        var tracingGeom = me.tracingFeature.getGeometry();
        var tracingCoords = tracingGeom.getCoordinates();

        var touchingIndex = me.tracingUtil.getCoordIndex(foundGeom.getCoordinates(), touchCoordinate);

        var hoverCoord = me.map.getCoordinateFromPixel(pixel);
        var foundSplitPoint = me.tracingUtil.getClosestCoordinateToPoint(foundGeom.getCoordinates(), hoverCoord);
        var hoverIndex = me.tracingUtil.getCoordIndex(foundGeom.getCoordinates(), foundSplitPoint);

        // we cut the tracing feature by the split point
        // we have to take the order into account
        var foundCoords = foundGeom.getCoordinates();
        var partUntilIntersection;
        if (hoverIndex >= touchingIndex) {
            partUntilIntersection = foundCoords.slice(touchingIndex, foundCoords.length);
        } else {
            partUntilIntersection = foundCoords.slice(0, touchingIndex + 1);
        }

        var newTracingCoords = me.tracingUtil.concatLineCoords(partUntilIntersection, tracingCoords);

        me.tracingFeature.getGeometry().setCoordinates(newTracingCoords);
        me.tracingFeatureArray.push(foundFeature);
    }
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="CpsiMapview.controller.LayerTreeController.html">LayerTreeController</a></li><li><a href="CpsiMapview.controller.button.TracingMixin.html">TracingMixin</a></li><li><a href="CpsiMapview.controller.form.LayerTreeFilter.html">LayerTreeFilter</a></li><li><a href="CpsiMapview.controller.form.Login.html">Login</a></li><li><a href="CpsiMapview.controller.panel.NumericAttributeSlider.html">NumericAttributeSlider</a></li><li><a href="CpsiMapview.data.model.LayerTreeNode.html">LayerTreeNode</a></li><li><a href="CpsiMapview.factory.Layer.html">Layer</a></li><li><a href="CpsiMapview.form.ControllerMixin.html">ControllerMixin</a></li><li><a href="CpsiMapview.form.HelpMixin.html">HelpMixin</a></li><li><a href="CpsiMapview.form.LayersMixin.html">LayersMixin</a></li><li><a href="CpsiMapview.form.RightInfoField.html">RightInfoField</a></li><li><a href="CpsiMapview.form.ValidationMessagesMixin.html">ValidationMessagesMixin</a></li><li><a href="CpsiMapview.form.ViewMixin.html">ViewMixin</a></li><li><a href="CpsiMapview.form.ViewModelMixin.html">ViewModelMixin</a></li><li><a href="CpsiMapview.form.field.Combo.html">Combo</a></li><li><a href="CpsiMapview.form.field.ComboLegacy.html">ComboLegacy</a></li><li><a href="CpsiMapview.model.fileupload.Attachment.html">Attachment</a></li><li><a href="CpsiMapview.plugin.ExpandPanel.html">ExpandPanel</a></li><li><a href="CpsiMapview.plugin.FeatureAttributeGrouping.html">FeatureAttributeGrouping</a></li><li><a href="CpsiMapview.plugin.TreeColumnContextMenu.html">TreeColumnContextMenu</a></li><li><a href="CpsiMapview.store.WfsFeatures.html">WfsFeatures</a></li><li><a href="CpsiMapview.util.ColumnMenuOrderMixin.html">ColumnMenuOrderMixin</a></li><li><a href="CpsiMapview.util.EditWindowOpenerMixin.html">EditWindowOpenerMixin</a></li><li><a href="CpsiMapview.util.Layer.html">Layer</a></li><li><a href="CpsiMapview.util.LayerTreeFilter.html">LayerTreeFilter</a></li><li><a href="CpsiMapview.util.Legend.html">Legend</a></li><li><a href="CpsiMapview.util.RoleManager.html">RoleManager</a></li><li><a href="CpsiMapview.util.Style.html">Style</a></li><li><a href="CpsiMapview.util.SwitchLayer.html">SwitchLayer</a></li><li><a href="CpsiMapview.util.Tracing.html">Tracing</a></li><li><a href="CpsiMapview.util.Turf.html">Turf</a></li><li><a href="CpsiMapview.util.WmsFilter.html">WmsFilter</a></li><li><a href="CpsiMapview.util.ZoomerMixin.html">ZoomerMixin</a></li><li><a href="CpsiMapview.view.button.DigitizeButton.html">DigitizeButton</a></li><li><a href="CpsiMapview.view.button.DrawingButton.html">DrawingButton</a></li><li><a href="CpsiMapview.view.button.FeatureSelectionButton.html">FeatureSelectionButton</a></li><li><a href="CpsiMapview.view.button.HelpButton.html">HelpButton</a></li><li><a href="CpsiMapview.view.button.LoginButton.html">LoginButton</a></li><li><a href="CpsiMapview.view.button.MinimizeAllButton.html">MinimizeAllButton</a></li><li><a href="CpsiMapview.view.button.PermalinkButton.html">PermalinkButton</a></li><li><a href="CpsiMapview.view.button.SpatialQueryButton.html">SpatialQueryButton</a></li><li><a href="CpsiMapview.view.button.SplitByClickButton.html">SplitByClickButton</a></li><li><a href="CpsiMapview.view.button.StreetViewTool.html">StreetViewTool</a></li><li><a href="CpsiMapview.view.fileupload.FileGrid.html">FileGrid</a></li><li><a href="CpsiMapview.view.fileupload.FileGridController.html">FileGridController</a></li><li><a href="CpsiMapview.view.fileupload.FileUploadWindow.html">FileUploadWindow</a></li><li><a href="CpsiMapview.view.fileupload.FileUploadWindowController.html">FileUploadWindowController</a></li><li><a href="CpsiMapview.view.fileupload.Report.html">Report</a></li><li><a href="CpsiMapview.view.from.LayerTreeFilter.html">LayerTreeFilter</a></li><li><a href="CpsiMapview.view.grid.ItemDeleter.html">ItemDeleter</a></li><li><a href="CpsiMapview.view.menuitem.LayerFilterReset.html">LayerFilterReset</a></li><li><a href="CpsiMapview.view.menuitem.LayerGrid.html">LayerGrid</a></li><li><a href="CpsiMapview.view.menuitem.LayerHelp.html">LayerHelp</a></li><li><a href="CpsiMapview.view.menuitem.LayerLabels.html">LayerLabels</a></li><li><a href="CpsiMapview.view.menuitem.LayerMetadata.html">LayerMetadata</a></li><li><a href="CpsiMapview.view.menuitem.LayerOpacity.html">LayerOpacity</a></li><li><a href="CpsiMapview.view.menuitem.LayerRefresh.html">LayerRefresh</a></li><li><a href="CpsiMapview.view.menuitem.LayerStyleSwitcher.html">LayerStyleSwitcher</a></li><li><a href="CpsiMapview.view.panel.NumericAttributeSlider.html">NumericAttributeSlider</a></li><li><a href="CpsiMapview.view.toolbar.CircleSelectionToolbar.html">CircleSelectionToolbar</a></li><li><a href="CpsiMapview.view.toolbar.MinimizedWindows.html">MinimizedWindows</a></li><li><a href="CpsiMapview.view.toolbar.ParallelLineToolbar.html">ParallelLineToolbar</a></li><li><a href="CpsiMapview.view.window.MinimizableWindow.html">MinimizableWindow</a></li><li><a href="CpsiMapview.view.window.ParallelLineWindow.html">ParallelLineWindow</a></li></ul><h3>Events</h3><ul><li><a href="global.html#event:cmv-init-layersaddedFireswhenallinitiallayersfromtheconfighavebeencreatedandaddedtotheOLmap.">cmv-init-layersadded
Fires when all initial layers from the config have been created and added to the OL map.</a></li><li><a href="global.html#event:cmv-mapclickFireswhentheOLmapisclicked.">cmv-mapclick
Fires when the OL map is clicked.</a></li><li><a href="global.html#event:parallelLineCreatedFires,whenanewparallellinewascreated.">parallelLineCreated
Fires, when a new parallel line was created.</a></li></ul><h3>Global</h3><ul><li><a href="global.html#TemplatefunctioncalledbeforedoingtheGetFeatureInforequestReturnfalseifyoudon'twanttomaketheGetFeatureInforequest.">Template function called before doing the GetFeatureInfo request
Return false if you don't want to make the GetFeatureInfo request.</a></li><li><a href="global.html#beforeSave">beforeSave</a></li><li><a href="global.html#getErrors">getErrors</a></li><li><a href="global.html#onAfterSaveSucceded">onAfterSaveSucceded</a></li><li><a href="global.html#onChange">onChange</a></li><li><a href="global.html#onFocus">onFocus</a></li><li><a href="global.html#onGroupEditToggle">onGroupEditToggle</a></li><li><a href="global.html#rawToValue">rawToValue</a></li><li><a href="global.html#setValue">setValue</a></li><li><a href="global.html#storeConfig">storeConfig</a></li><li><a href="global.html#validate">validate</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Fri Jan 24 2025 13:53:46 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
